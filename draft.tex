\documentclass[12pt,twoside,a4paper]{report}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{enumerate}
\usepackage[vmargin=2.5cm, hmargin=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{stackengine}
\usepackage{minitoc}
\usepackage{amsthm}
\usepackage{listings}

\setmainfont{Linux Libertine O}
\setsansfont{Linux Biolinum O}

\graphicspath{{./fig/category_theory/}}

\setlength{\parindent}{0em}
\addtolength{\parskip}{1ex}

\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{ref.bib}

\theoremstyle{definition}
\newtheorem*{definition*}{Definition}

\newcounter{motivation}
\renewcommand{\themotivation}{\Roman{motivation}}

\newcommand{\motivation}[1]{%
    \refstepcounter{motivation}%
    \vspace{1.5em}%
    \noindent\textbf{Motivation \themotivation.  #1}
    \par
    \expandafter\edef\csname savedmotivation\themotivation\endcsname{%
        \noexpand\noindent\noexpand\textbf{Motivation \themotivation. #1}\noexpand\par
    }%
}

\begin{document}

\dominitoc

\title{Using functor categories to generate intermediate code with Agda}
\author{Jack Gao}
\date{\today}
\maketitle

\tableofcontents
\newpage

\chapter{Introduction}
    \minitoc
    An Algol-like language is a typed lambda calculus with store. In this dissertation, the source language is an Algol-like language with the following primitive types:
    \begin{itemize}
        \item 
            \textbf{comm}: the commands
        \item 
            \textbf{intexp}: the integer expressions
        \item 
            \textbf{intacc}: the integer acceptors
        \item 
            \textbf{intvar}: the integer variables
    \end{itemize}
    and the set $\Theta$ of types is defined as follows:
    \[ \Theta := \textbf{comm} \mid \textbf{intexp} \mid \textbf{intacc} \mid \textbf{intvar} \mid \Theta \to \Theta \]

    [Considering adding an example of Algol-like language here]

    The target language is an assembly-style intermediate language for a stack machine. It is defined with four stack-descriptor-indexed families of non-terminals: 
    \begin{itemize}
        \item 
            $\langle\text{L}_{sd}\rangle$: lefthand sides
        \item 
            $\langle\text{S}_{sd}\rangle$: Simple righthand sides
        \item
            $\langle\text{R}_{sd}\rangle$: righthand sides
        \item
            $\langle\text{I}_{sd}\rangle$: instruction sequences
    \end{itemize}

    The grammer of the target language is specified in Chapter 3.

    This dissertation presents an implementation of a compiler from the source language to the target language with Agda \cite{Agda}. This implementation is based on the work of Reynolds \cite{Reynolds}, who presented a denotational semantics of Algol-like languages in the form of a presheaf category over stack descriptors. The compiler is implemented as a functor from the source language to the target language. The implementation is verified with Agda's type system, which ensures that the generated code is well-typed and adheres to the semantics of both the source and target languages. This implementation proves and refines Reynolds' work, providing a practical example of how to use functor categories to generate intermediate code.

    \section{Motivation and related work}
        The denotational semantics of Algol-like languages can be structured as a presheaf category over stack descriptors, which has been shown by Reynolds \cite{essence} and Oles \cite{Oles_1} \cite{Oles_2}. By interpreting the source language into this category, where objects of the category represent instruction sequences parameterised by stack layouts, the semantic model directly yields a compiler. The mathematical structure of the compiler has been specified by Reynolds in his paper ``Using Functor Categories to Generate Intermediate Code'' \cite{Reynolds}.

        This project is motivated and guided by the following:

        \motivation{Implementation of the compiler}
        Reynolds concluded that he did not have a proper dependently typed programming language in hand, so his compiler remained a partial function theoretically. We aim to provide a computer implementation of this theoretical framework in a dependently typed programming language.
        

        \motivation{Formal verification of the compiler}
        The terms in Reynolds' work are also written by hand. Terms are complicated and error-prone, and it is difficult to verify the correctness of the terms. We aim to provide a formalisation of the terms in a proof assistant to verify the correctness of the terms.
        
        \motivation{Trend of verified compilers}
        The rise of verified compilers including CompCert \cite{CompCert}, CakeML \cite{CakeML} reflects a broader trend toward trustworthy systems, where correctness proofs replace testing for critical guarantees. Like Lean 4 \cite{Lean4}, we leverage dependent types to internalise the verification of correctness of terms.

    
    \section{Language choice: Agda's advantages}
        Agda \cite{Agda} is a dependently typed programming language and proof assistant. Agda captures the source language's intrinsic sytax with indexed families, which contains only well-typed terms. Therefore, it focuses on the correct programs and rules out the ill-typed nonsensical inputs. 

        (Example of Agda)

        Dependently typed languages provide a natural framework for expressing functor categories is proven both theoretically and practically. There have been dependent-type-theoretic model of categories \cite{Dybjer}, and it has been shown that functor categories arise naturally as dependent function types \cite{Jacobs}. A formalisation of Category Theory, including Cartesian Closed Categories, functors and presheaves has been developed in Agda by Hu and Caratte \cite{Cat_Agda}. Other proof assistants, such as Isabelle/Hol, does not have a dependently typed language structure, and thus cannot express the functor categories as naturally as Agda.

        [Do I need a table for comparing other proof assistants and Agda?]

    \section{Contributions}
        Addressed the two motivations presented in 1.1 and contributed to the following:
        \begin{quote}
            \savedmotivationI
            We implemented the compiler from the source language to the target language in Agda. 

            \savedmotivationII
            We formalised the terms in the source language and target language in Agda, and proved that the compiler is a functor from the source language to the target language. 

            \savedmotivationIII
            This implementation follows the trend of verified compilers, and provides a practical example of how to use functor categories to generate intermediate code.
        \end{quote}


\chapter{Preparation}
    \minitoc

    \section{Starting Point}
    Prior to this project, I had no experience with Agda. Although I was aware of the open-source online tutorial \textit{Programming Language Foundations in Agda} (PLFA) \cite{plfa}, my preparation was limited to setting up the Agda environment on my laptop by following the ``Front Matter'' section of the tutorial.

    I did not have any other experience with compiler beyond Part IB Compiler Construction Course. I had no prior exposure to category theory and type theory before the Part II lectures.

    \section{Category theory background}
        Category 
        \subsection{Category}
        \begin{definition*}[Category]
            A \emph{category} $\mathcal{C}$ is specified by the following:
            \begin{itemize}
                \item 
                    a collection of objects $\textbf{obj}(\mathcal{C})$, whose elements are called $\mathcal{C}$-objects;
                \item 
                    for each $X, Y \in \textbf{obj}(\mathcal{C})$, a collection of morphisms $\mathcal{C}{(X,Y)}$, whose elements are called $\mathcal{C}$-morphisms from $X$ to $Y$;
                \item 
                    for each $X \in \textbf{obj}(\mathcal{C})$, an element $\textbf{id}_X \in \mathcal{C}{(X,X)}$ called the identity morphism on $X$;
                \item 
                    for each $X, Y, Z \in \textbf{obj}(\mathcal{C})$, a function 
                    \[\begin{aligned}
                        \mathcal{C}{(X,Y)} \times \mathcal{C}{(Y,Z)} &\to \mathcal{C}{(X,Z)} \\
                        (f,g) &\mapsto g \circ f
                    \end{aligned}\]
                    called the composition of morphisms;
            \end{itemize}
            satisfying the following properties:
            \begin{itemize}
                \item 
                    \textbf{(Unit Laws)}
                    for all $X, Y \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$, we have:
                    \begin{equation} \label{law: unit}
                        \textbf{id}_Y \circ f = f = f \circ \textbf{id}_X
                    \end{equation}
                \item
                    \textbf{(Associativity Law)}
                    for all $X, Y, Z, W \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$, $g \in \mathcal{C}{(Y,Z)}$, $h \in \mathcal{C}{(Z,W)}$, we have:
                    \begin{equation} \label{law: associativity}
                        h \circ (g \circ f) = (h \circ g) \circ f
                    \end{equation}
            \end{itemize}

            [Considering adding different notations for morphisms, composition, identity morphisms, etc.]

            [Considering adding a diagram for the definition of category]

            [Considering adding examples of categories]

        \end{definition*}

            \subsubsection{Opposite category}
            The idea of opposite category is that if we have a category $\mathcal{C}$, we can reverse the direction of all morphisms in $\mathcal{C}$ to obtain a new category $\mathcal{C}^{\textbf{op}}$.

            \begin{definition*}[Opposite category]
                Given a category $\mathcal{C}$, its \emph{opposite category} $\mathcal{C}^{\textbf{op}}$ is specified by:
                \begin{itemize}
                    \item 
                        the objects of $\mathcal{C}^{\textbf{op}}$ are the same as those of $\mathcal{C}$;
                    \item 
                        for each $X, Y \in \textbf{obj}(\mathcal{C})$, the morphisms from $X$ to $Y$ in $\mathcal{C}^{\textbf{op}}$ are the morphisms from $Y$ to $X$ in $\mathcal{C}$;
                    \item 
                        the identity morphism on $X$ in $\mathcal{C}^{\textbf{op}}$ is the identity morphism on $X$ in $\mathcal{C}$;
                    \item 
                        the composition of morphisms in $\mathcal{C}^{\textbf{op}}$ is defined as the composition of morphisms in $\mathcal{C}$.
                \end{itemize}
            \end{definition*}

                % \paragraph{The principle of duality}
                % Whenever one defines a concept or proves a theorem in category theory $\mathcal{C}$, one can obtain another concept or theorem in the opposite category $\mathcal{C}^{\textbf{op}}$, called the \emph{dual} of the original concept or theorem, by reversing all arrows in the original concept or theorem.

            The notation of commutative diagram is widely used in category theory as a convenient visual representation of the relationships between objects and morphisms in a category.
            \subsubsection{Commutative diagrams}
            A \emph{diagram} in a category $\mathcal{C}$ is a directed graph whose vertices are $\mathcal{C}$-objects and whose edges are $\mathcal{C}$-morphisms.

            A diagram is \emph{commutative} (or \emph{commutes}) if any two finite paths in the graph between any two vertices $X$ and $Y$ in the diagram determine the equal morphism $f \in \mathcal{C}{(X,Y)}$ under the composition of morphisms.

            \begin{figure}[htb!]
                \centering
                \begin{minipage}{0.3\textwidth}
                    \centering
                    \includegraphics[width=0.8\textwidth]{unit_laws.pdf}
                    \caption{Commutative diagram for Unit Laws}
                    \label{fig: unit_laws}
                \end{minipage} \hspace{0.2\textwidth}
                \begin{minipage}{0.3\textwidth}
                    \centering
                    \includegraphics[width=0.8\textwidth]{associativity_law.pdf}
                    \caption{Commutative diagram for Associativity Law}
                    \label{fig: associativity_law}
                \end{minipage}
            \end{figure}

            As examples of commutative diagrams, Figure \ref{fig: associativity_law} and Figure \ref{fig: unit_laws} are commutative diagrams for the unit laws and associativity law respectively. 

        \subsection{Isomorphism}
        \begin{definition*}[Isomorphism]
            Given a category $\mathcal{C}$, a $C$-morphism $f : X \to Y$ is called an \emph{isomorphism} if there exists a $C$-morphism $g : Y \to X$ such that the following diagram commutes:
            \begin{equation}
                \vcenter{\hbox{\includegraphics[width=0.3\textwidth]{isomorphism.pdf}}}
                \label{cd: isomorphism}
            \end{equation}
            In other words, $f$ is an isomorphism if there exists a morphism $g$ such that $g \circ f = \textbf{id}_X$ and $f \circ g = \textbf{id}_Y$.

            The morphism $g$ is uniquely determined by $f$ and is called the \emph{inverse} of $f$, denoted as $f^{-1}$.

            Given two objects $X$ and $Y$ in a category $\mathcal{C}$, if there exists an isomorphism from $X$ to $Y$, we say that $X$ and $Y$ are \emph{isomorphic} in $\mathcal{C}$ and write $X \cong Y$.

        \end{definition*}
        [Considering adding examples of isomorphism]
        

        \subsection{Terminal object}
        \begin{definition*}[Terminal object]
            Given a category $\mathcal{C}$, an object $T \in \textbf{obj}(\mathcal{C})$ is called a \emph{terminal object} if for all $X \in \textbf{obj}(\mathcal{C})$, there exists a unique \textbf{C}-morphism $f : X \to T$.
        \end{definition*}
        [Considering adding examples of terminal object]

        Terminal objects are unique up to isomorphism. In other words, we have
        \begin{itemize}
            \item 
                if $T$ and $T'$ are both terminal objects in $\mathcal{C}$, then there exists a unique isomorphism $f : T \to T'$.
            \item
                if $T$ is a terminal object in $\mathcal{C}$ and $T \cong T'$, then $T'$ is also a terminal object in $\mathcal{C}$.
        \end{itemize}

        % \subsection{Initial object}
        % \begin{definition*}[Initial object]
        %     Given a category $\mathcal{C}$, an object $I \in \textbf{obj}(\mathcal{C})$ is called an \emph{initial object} if for all $X \in \textbf{obj}(\mathcal{C})$, there exists a unique \textbf{C}-morphism $f : I \to X$.
        % \end{definition*}
        % Initial object is dual to terminal object. By the principle of duality, initial objects are unique up to isomorphism. In other words, we have
        % \begin{itemize}
        %     \item 
        %         if $I$ and $I'$ are both initial objects in $\mathcal{C}$, then there exists a unique isomorphism $f : I \to I'$.
        %     \item
        %         if $I$ is an initial object in $\mathcal{C}$ and $I \cong I'$, then $I'$ is also an initial object in $\mathcal{C}$.
        % \end{itemize}

        \subsection{Binary product}
        \begin{definition*}[Binary product]
            Given a category $\mathcal{C}$, the \emph{binary product} of two objects $X$ and $Y$ in $\mathcal{C}$ is specified by
            \begin{itemize}
                \item a $\mathcal{C}$-object $X \times Y$;
                \item two $\mathcal{C}$-morphisms $\pi_1 : X \times Y \to X$ and $\pi_2 : X \times Y \to Y$ called the \emph{projections} of $X \times Y$;
            \end{itemize}
            such that for all $Z \in \textbf{obj}(\mathcal{C})$ and morphisms $f : Z \to X$ and $g : Z \to Y$, there exists a unique morphism $u : Z \to X \times Y$ such that the following diagram commutes in $\mathcal{C}$:
            \begin{equation}
                \vcenter{\hbox{\includegraphics[width=0.4\textwidth]{binary_product.pdf}}}
                \label{cd: binary_product}
            \end{equation}
            The unique morphism $u$ is written as 
            \[ \langle x, y \rangle : Z \to X \times Y \]
            where $x = \pi_1 \circ u$ and $y = \pi_2 \circ u$.
        \end{definition*}
        It can be shown that the binary product is unique up to (unique) isomorphism.


        \subsection{Exponential}
        \begin{definition*}[Exponential]
            Given a category $\mathcal{C}$ with binary products, the \emph{exponential} of two objects $X$ and $Y$ in $\mathcal{C}$ is specified by
            \begin{itemize}
                \item a $\mathcal{C}$-object $X \Rightarrow Y$;
                \item a $\mathcal{C}$-morphism $\textbf{app} : (X \Rightarrow Y) \times X \to Y$ called the \emph{application} of $X \Rightarrow Y$;
            \end{itemize}
            such that for all $Z \in \textbf{obj}(\mathcal{C})$ and morphisms $f : Z \times X \to Y$, there exists a unique morphism $u : Z \to X \Rightarrow Y$ such that the following diagram commutes in $\mathcal{C}$:
            \begin{equation}
                \vcenter{\hbox{\includegraphics[width=0.4\textwidth]{exponential.pdf}}}
                \label{cd: exponential}
            \end{equation}
            We write $\textbf{cur} f$ for the unique morphism $u$ such that $f = \textbf{app} \circ (\textbf{cur} f \times \textbf{id}_X)$, 
            where $\textbf{cur} f$ is called the \emph{currying} of $f$.
        \end{definition*}
        It can be shown that the exponential is unique up to (unique) isomorphism.

    
        \subsection{Cartesian closed category}
        \begin{definition*}[Cartesian closed category]
            A category $\mathcal{C}$ is called a \emph{Cartesian closed category} (ccc) if it has a terminal object, binary products and exponentials of any two objects.
        \end{definition*}

        \subsection{Functor}
        \begin{definition*}[Functor]
            Given two categories $\mathcal{C}$ and $\mathcal{D}$, a \emph{functor} $F: \mathcal{C} \to \mathcal{D}$ is specified by:
            \begin{itemize}
                \item 
                    a function 
                    \[\begin{aligned}
                        \textbf{obj}(\mathcal{C}) &\to \textbf{obj}(\mathcal{D}) \\
                        X &\mapsto F(X)
                    \end{aligned}\]

                \item 
                    for each $X, Y \in \textbf{obj}(\mathcal{C})$, a function 
                    \[\begin{aligned}
                        \mathcal{C}{(X,Y)} &\to \mathcal{D}{(F(X),F(Y))} \\
                        f &\mapsto F(f)
                    \end{aligned}\]
            \end{itemize}
            satisfying the following properties:
            \begin{itemize}
                \item 
                    for all $X, Y \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$, we have:
                    \begin{equation} \label{law: functor_id}
                        F(\textbf{id}_X) = \textbf{id}_{F(X)}
                    \end{equation}
                \item
                    for all $X, Y, Z \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$, $g \in \mathcal{C}{(Y,Z)}$, we have:
                    \begin{equation} \label{law: functor_comp}
                        F(g \circ f) = F(g) \circ F(f)
                    \end{equation}
            \end{itemize}
        \end{definition*}
        [Considering adding examples of functors: e.g. free functor, forgetful functor, etc.]

        \subsection{Natural transformation}
        \begin{definition*}[Natural transformation]

            Given two categories $\mathcal{C}$ and $\mathcal{D}$, and two functors $F,G: \mathcal{C} \to \mathcal{D}$, a \emph{natural transformation} $\theta : F \to G$ is a family of morphisms $\theta_X \in \mathcal{D}{(F(X),G(X))}$ for each $X \in \textbf{obj}(\mathcal{C})$ such that for all $X, Y \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$, the following diagram 
            \begin{equation}
                \vcenter{\hbox{\includegraphics[width=0.3\textwidth]{natural_transformation.pdf}}}
                \label{cd: natural_transformation}
            \end{equation}
            
            commutes in $\mathcal{D}$, i.e. the following equation holds:
            \begin{equation} \label{law: natural_transformation}
                G(f) \circ \theta_X = \theta_Y \circ F(f)
            \end{equation}

        \end{definition*}
        [Considering adding examples of natural transformations]

        \subsection{Functor category}
        \begin{definition*}[Functor category]
            Given two categories $\mathcal{C}$ and $\mathcal{D}$, the \emph{functor category} $\mathcal{D}^{\mathcal{C}}$ is the category satisfying the following:
            \begin{itemize}
                \item 
                    the objects of $\mathcal{D}^{\mathcal{C}}$ are all functors $\mathcal{C} \to \mathcal{D}$;
                \item 
                    given two functors $F,G: \mathcal{C} \to \mathcal{D}$, the morphisms from $F$ to $G$ in $\mathcal{D}^{\mathcal{C}}$ are all natural transformations $\theta : F \to G$;
                \item
                    composition and identity morphisms in $\mathcal{D}^{\mathcal{C}}$ are defined as follows:
                    \begin{itemize}
                        \item 
                            the identity morphism $\textbf{id}_F$ on $F$ is defined as $\theta_X = \textbf{id}_{F(X)}$ for all $X \in \textbf{obj}(\mathcal{C})$;
                        \item
                            the composition of two natural transformations $\theta : F \to G$ and $\phi : G \to H$ is defined as $(\phi \circ \theta)_X = \phi_X \circ \theta_X$ for all $X \in \textbf{obj}(\mathcal{C})$.
                    \end{itemize}
            \end{itemize}
        \end{definition*}

        \subsection{Yoneda lemma}
        \begin{definition*}[Yoneda functor]
            Given a category $\mathcal{C}$, the \emph{Yoneda functor} $y: \mathcal{C} \to \mathcal{C}^{\mathcal{C}^{op}}$ is defined as follows:
            \begin{itemize}
                \item 
                    for each $X \in \textbf{obj}(\mathcal{C})$, $y(X)$ is the functor $y(X): \mathcal{C}^{op} \to \textbf{Set}$ defined as:
                    \[ y(X)(Y) = \mathcal{C}{(Y,X)} \]
                    for all $Y \in \textbf{obj}(\mathcal{C})$;
                \item
                    for each $X, Y \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$, $y(f)$ is the natural transformation $y(f): y(X) \to y(Y)$ defined as:
                    \[ y(f)_Y = f \circ - : y(X)(Y) \to y(Y)(Y) \]
                    for all $Y \in \textbf{obj}(\mathcal{C})$.
                    In other words, $y(f)_Y$ is the function that takes an element $g \in y(X)(Y) = \mathcal{C}{(Y,X)}$ and returns the element $f \circ g \in y(Y)(Y) = \mathcal{C}{(Y,Y)}$.
                    The function $y(f)_Y$ is a morphism in $\mathcal{C}^{\mathcal{C}^{op}}$ from $y(X)(Y)$ to $y(Y)(Y)$.
                    In other words, $y(f)_Y$ is a morphism in $\mathcal{C}^{\mathcal{C}^{op}}$ from the functor $y(X)$ to the functor $y(Y)$.
                    The morphism $y(f)_Y$ is defined for all $Y \in \textbf{obj}(\mathcal{C})$.
                    In other words, $y(f)$ is a natural transformation from the functor $y(X)$ to the functor $y(Y)$.
            \end{itemize}
        \end{definition*}

        \begin{definition*}[Yoneda lemma]
            Given a category $\mathcal{C}$, the \emph{Yoneda lemma} states that for any functor $F: \mathcal{C} \to \textbf{Set}$, there is a natural isomorphism:
            \[ \begin{aligned}
                \textbf{Nat}(y(X),F) &\cong F(X) \\
                \theta &\mapsto \theta_X
            \end{aligned} \]
            for all $X \in \textbf{obj}(\mathcal{C})$, where $\textbf{Nat}(y(X),F)$ is the set of natural transformations from the functor $y(X)$ to the functor $F$.
        \end{definition*}

        \subsection{Presheaf}
        \begin{definition*}[Presheaf]
            Given a category $\mathcal{C}$, a \emph{presheaf} on $\mathcal{C}$ is a functor $F: \mathcal{C}^{op} \to \textbf{Set}$.
            A presheaf is a contravariant functor, which means that it reverses the direction of morphisms.
            In other words, a presheaf is a functor that takes objects in $\mathcal{C}$ and assigns them sets, and takes morphisms in $\mathcal{C}$ and assigns them functions between the corresponding sets.
            The presheaf $F$ is defined as follows:
            \begin{itemize}
                \item 
                    for each $X \in \textbf{obj}(\mathcal{C})$, $F(X)$ is a set;
                \item
                    for each $X, Y \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$, $F(f)$ is a function $F(Y) \to F(X)$.
                    In other words, $F(f)$ is a function that takes an element $g \in F(Y)$ and returns the element $f \circ g \in F(X)$.
                    The function $F(f)$ is a morphism in $\mathcal{C}^{op}$ from $F(Y)$ to $F(X)$.
                    In other words, $F(f)$ is a morphism in $\mathcal{C}^{op}$ from the functor $F(Y)$ to the functor $F(X)$.
                    The morphism $F(f)$ is defined for all $X, Y \in \textbf{obj}(\mathcal{C})$ and $f \in \mathcal{C}{(X,Y)}$.
                    In other words, $F(f)$ is a natural transformation from the functor $F(Y)$ to the functor $F(X)$.
            \end{itemize}
        \end{definition*}

        \subsection{Cartesian closed structure in presheaf categories}
        


    \section{Agda}
        \subsection{Basic datatypes and pattern matching}
        We will go through a simple example in PLFA \cite{plfa} to illustrate the basic datatypes and pattern matching in Agda.

        \subsection{Dependent Types}


        \subsection{Curry-Howard-Lambek correspondence}

        \subsection{Equality, congruence and substitution}

        % \subsection{Proof Example}

        \subsection{Standard library}
        
        \subsection{Interactive programming with holes}
        A feature of Agda is that it allows us to write programs with holes interatively. A hole is a placeholder for a term that we have not yet defined. By leaving holes in place of undefined terms, we can write programs that are incomplete but still type-check, and Agda's type checker will guide completion of the program: the context window displays inferred types of the holes, available variables and candidate terms with their types. Holes also supports case split and refinement, which means we can fill in a hole partially and split it into smaller holes. 

        [Considering adding examples of holes and case split, see https://plfa.github.io/Naturals/]

        In my implementation, I used holes to write the terms in the compiler. The complex terms are incrementally filled and verified by interatively refining partial implementations, reducing post-hoc debugging and ensuring robustness.


    \section{Requirement Analysis}

    \section{Tools Used}
    Completing the project is an iterative process. I used Git \cite{git} for version control, and work had been synchronised with a GitHub \cite{github} repository for backup.

    For the development environment, I tried both Emacs \cite{emacs} and Visual Studio Code \cite{vscode} with an agda-mode extension \cite{agda_mode} on Windows Subsystem for Linux with Ubuntu \cite{wsl_ubuntu} 22.04 LTS. I am more familiar with the snippet and syntax highlighting features of Visual Studio Code, so I used it for most of the development. 

    Code from the PLFA tutorial and Agda standard library \cite{agda_std} were used as references. 

\chapter{Implementation}

\chapter{Evaluation}

\chapter{Conclusion}

    \printbibliography

\end{document}